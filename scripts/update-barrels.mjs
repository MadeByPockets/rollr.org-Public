#!/usr/bin/env node
import fs from 'node:fs';
import path from 'node:path';

function toPosix(p) {
  return p.split(path.sep).join('/');
}

function isTsLike(file) {
  const ext = path.extname(file);
  return ext === '.ts' || ext === '.tsx';
}

function shouldSkipFile(fileBase, fileName) {
  // Skip declaration files and common non-source files
  if (fileName.endsWith('.d.ts')) return true;
  if (/\.(test|spec|stories)\.(ts|tsx)$/.test(fileName)) return true;
  if (fileName.startsWith('.')) return true;
  return false;
}

function walkCollectModules(dir) {
  const out = [];
  function walk(currentDir) {
    const items = fs.readdirSync(currentDir, { withFileTypes: true });
    for (const d of items) {
      const full = path.join(currentDir, d.name);
      if (d.isDirectory()) {
        // Skip node_modules and hidden dirs
        if (d.name === 'node_modules' || d.name.startsWith('.')) continue;
        walk(full);
      } else if (d.isFile() && isTsLike(d.name)) {
        const base = path.basename(d.name, path.extname(d.name));
        if (shouldSkipFile(base, d.name)) continue;
        let relNoExt = toPosix(path.relative(dir, full)).replace(/\.(ts|tsx)$/i, '');
        // Skip the root index file itself if encountered
        if (relNoExt === 'index') continue;
        // If file is .../index.ts, treat it as the folder export
        if (relNoExt.endsWith('/index')) relNoExt = relNoExt.slice(0, -('/index'.length));
        out.push(relNoExt);
      }
    }
  }
  walk(dir);
  // De-duplicate and sort (stable)
  return Array.from(new Set(out)).sort((a, b) => a.localeCompare(b));
}

function generateBarrelContent(modules, rootDirLabel) {
  const lines = [];
  lines.push('// AUTO-GENERATED FILE. DO NOT EDIT.');
  lines.push('// Generated by scripts/update-barrels.mjs');
  lines.push(`// Barrel for ${rootDirLabel} â€” exports all .ts/.tsx (excluding tests, stories, .d.ts)`);
  lines.push('');
  for (const m of modules) {
    lines.push(`export * from "./${m}";`);
  }
  lines.push('');
  return lines.join('\n');
}

function writeBarrel(targetDir) {
  const absDir = path.resolve(process.cwd(), targetDir);
  if (!fs.existsSync(absDir)) {
    console.error(`[update-barrels] Skip: ${targetDir} does not exist.`);
    return false;
  }
  const modules = walkCollectModules(absDir);
  const content = generateBarrelContent(modules, targetDir);
  const outPathTs = path.join(absDir, 'index.ts');
  const outPathTsx = path.join(absDir, 'index.tsx');

  // If there is a hand-written TSX index, do not shadow it with a generated TS barrel
  if (fs.existsSync(outPathTsx)) {
    if (fs.existsSync(outPathTs)) {
      const current = fs.readFileSync(outPathTs, 'utf8');
      if (current.startsWith('// AUTO-GENERATED FILE. DO NOT EDIT.')) {
        try {
          fs.unlinkSync(outPathTs);
          console.log(`[update-barrels] Removed auto-generated index.ts in ${targetDir} to defer to existing index.tsx`);
        } catch {}
      }
    }
    console.log(`[update-barrels] Found existing index.tsx in ${targetDir}; skipping generation of index.ts`);
    return false;
  }

  // If no modules to export, avoid creating an empty barrel. Remove stale auto-generated barrel if present.
  if (modules.length === 0) {
    if (fs.existsSync(outPathTs)) {
      const current = fs.readFileSync(outPathTs, 'utf8');
      if (current.startsWith('// AUTO-GENERATED FILE. DO NOT EDIT.')) {
        try {
          fs.unlinkSync(outPathTs);
          console.log(`[update-barrels] Removed empty auto-generated index.ts in ${targetDir}`);
        } catch {}
      }
    }
    return false;
  }

  fs.writeFileSync(outPathTs, content, 'utf8');
  console.log(`[update-barrels] Wrote ${path.relative(process.cwd(), outPathTs)} with ${modules.length} export lines.`);
  return true;
}

function listAllDirs(root) {
  const out = [];
  function walk(dir) {
    out.push(dir);
    const items = fs.readdirSync(dir, { withFileTypes: true });
    for (const d of items) {
      if (d.isDirectory()) {
        if (d.name === 'node_modules' || d.name.startsWith('.')) continue;
        walk(path.join(dir, d.name));
      }
    }
  }
  if (fs.existsSync(root)) walk(root);
  return out;
}

function cleanAutoGeneratedBarrels(targetDir) {
  const abs = path.resolve(process.cwd(), targetDir);
  if (!fs.existsSync(abs)) return 0;
  let removed = 0;
  const dirs = listAllDirs(abs);
  for (const d of dirs) {
    const tsPath = path.join(d, 'index.ts');
    const tsxPath = path.join(d, 'index.tsx');
    try {
      // Never touch hand-written TSX barrels
      if (fs.existsSync(tsxPath)) continue;
      if (fs.existsSync(tsPath)) {
        const text = fs.readFileSync(tsPath, 'utf8');
        if (text.startsWith('// AUTO-GENERATED FILE. DO NOT EDIT.')) {
          fs.unlinkSync(tsPath);
          removed++;
          console.log(`[update-barrels] Deleted prior auto-generated barrel: ${toPosix(path.relative(process.cwd(), tsPath))}`);
        }
      }
    } catch (e) {
      console.warn(`[update-barrels] Failed to inspect/delete ${toPosix(path.relative(process.cwd(), tsPath))}: ${e?.message || e}`);
    }
  }
  return removed;
}

function writeBarrelsRecursively(targetDir) {
  const abs = path.resolve(process.cwd(), targetDir);
  if (!fs.existsSync(abs)) {
    console.error(`[update-barrels] Skip: ${targetDir} does not exist.`);
    return false;
  }
  const allDirs = listAllDirs(abs)
    .map(d => toPosix(path.relative(process.cwd(), d)))
    // Process deepest paths first so children are cleaned/generated before parents
    .sort((a, b) => (b.split('/').length - a.split('/').length));
  let any = false;
  for (const rel of allDirs) {
    any = writeBarrel(rel) || any;
  }
  return any;
}

function main() {
  // Default targets
  const targets = process.argv.slice(2).length ? process.argv.slice(2) : [
    'src/components',
    'src/mocks',
  ];
  let wroteAny = false;
  for (const t of targets) {
    // First, remove any prior auto-generated barrels under this target
    const removed = cleanAutoGeneratedBarrels(t);
    if (removed > 0) {
      console.log(`[update-barrels] Cleaned ${removed} auto-generated barrel(s) under ${t}`);
    }
    // Then (re)generate barrels deepest-first
    wroteAny = writeBarrelsRecursively(t) || wroteAny;
  }
  if (!wroteAny) {
    process.exitCode = 1;
  }
}

try {
  main();
} catch (err) {
  console.error('[update-barrels] Failed:', err?.message || err);
  process.exit(1);
}
